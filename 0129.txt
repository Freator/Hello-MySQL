需求： A给B转账：A账户先减少，B再增加，但是A操作后断电
解决方案：A减少钱，答案是不要立即修改数据表，B收到钱后，同时修改数据表


事务（transaction）安全：
事务：一系列连续要发生的操作


事务操作 自动事务（默认）和手动事务操作

手动事务：操作流程：
1. 开启事务:告诉系统所有的写操作先存入到事务日志中（打不开）
start transaction
2.进行事务操作：一系列的，A账户减少B同时增加
3.关闭事务：选择性的将日志文件中的操作结果保存到数据表（同步）或者说直接清空事务日志（原来操作全部清空）：
   （1）提交事务：同步数据表（操作成功）：commit
   （2）回滚事务：清空日志表（操作失败）：rollback

事务原理：事务开启后都会临时保存到事务日志，只有在commit命令后才能同步到数据表，其他任何情况都会清空




回滚点：
在某个操作后的操作可能成功或者失败，但是当前操作之前的都成功了，那可以设置此点为回滚点
设置回滚点：savepoint 回滚点名字;
回到回滚点：rollback to 回滚点名字;



自动事务处理
系统通过autocommit变量控制：show variables like 'autocommit';


事务四大特性：ACID
 A：atomic 原子性
 C：consistency 一致性
 I：isolation 隔离性
 D：durability 持久性，数据一旦提交，不可以改变


锁机制：innodb默认是行锁，但在事务操作过程中如果没有使用索引，那么系统会自动全表检索数据，自动升级为表锁：
     行锁：只是当前行被锁住，别的用户不能操作
     表锁：整张表被锁住




变量：系统变量和自定义变量

系统变量：系统定义好的变量：大部分的时候不需要使用，该变量是用来控制服务器的表现的
查看具体变量 ： select @@变量名;
修改系统变量：会话级别和全局级别
     会话级别：临时修改，当次有效：set 变量名 = 值;
                                   set @@变量名 = 值;
      全局级别：一次修改对所有客户端生效set global 变量名 = 值;
对于全局来讲，当前其他客户端当次无效，需要重新登录才会生效




自定义变量：
为了区分系统变量，规定自定义变量只能使用一个@符号
set @变量名 = 值;
查看自定义变量：还是用select @变量名;（一个@）

在mysql中  ‘=’默认或者更多是看成一个比较符号，为了区分，MYSQL中的赋值符号为 ： ':='


MySQL允许从数据表中获取数据然后赋值给变量：两种方式

（1）边赋值边查看变量
select @变量名 := 字段名 from 数据源;
（2）只有赋值，不看结果：数据记录最多只允许获取一条，不支持数据
select 字段列表 from 表名 into  变量列表;


所有自定义的变量都是会话级别，当次有效，且不区分数据库







触发器：trigger，事先为某张表绑定好一段代码，当有增删改操作改变表内容时，系统自动触发代码，执行
触发器包括事件类型，触发时间，触发对象
（1）事件类型：增删改insert，delete，update
（2）触发时间：前后：before，after
（3）触发对象：针对表中一行记录

一张表中只能拥有一种触发时间的一种类型的触发器：一张表最多6种



创建触发器：
在mysql高级结构中，用对应的字母符号代替括号
语法：create trigger 触发器名字 触发时间 触发类型 on 表名 for each row begin(代表开始)
（中间为触发器内容） 
end(代表结束)
-- 语句结束符
其中语句结束符可以自定义：临时修改,不用分号作为语句结束符，但是触发器内容必须使用分号作为语句结束符，所以在这之后又必须将临时修改修正过来

临时修改语句结束符：delimiter 自定义符号
将临时修改修正过来 delimiter ;



查看触发器:
查看所有触发器或者模糊匹配：
show triggers [like 'pattern'];

所有的触发器都会存在一张表中：information_schema.triggers
可以 select * from information_schema.triggers


使用触发器：自动触发

修改和删除：触发器只能先删除后新增，不能直接修改，
drop trigger 触发器名字;



