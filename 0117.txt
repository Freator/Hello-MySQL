1NF：不可拆分，即取出来就可以用，不需要进行额外拆分处理，具有原子性
2NF：在有复合主键的情况下，解决部分依赖问题
3NF：解决传递依赖问题，单独再建表



逆规范化：提高查询效率，但是有数据冗余







数据高级操作（结合文档0117.sql）

1、新增数据：基本语法  insert into 表名[(字段名)] values(值列表);

主键冲突时
（1）更新：insert into 表名[(字段列表：包含主键)] values(值列表) on dupilcate key update 字段 = 新值;
（2）替换 :replace into 表名[(字段列表：包含主键)]values(值列表);



2、蠕虫复制（实际很少能涉及到）
从已有数据中获取数据然后进行新增操作，数据成倍增加

表创建高级操作（复制表结构）
create table 表名 like 数据库名.表名;  

蠕虫复制：先查数据再新增一遍所查询的数据
insert into 表名[(字段列表)] select 字段列表/*from 数据表名;

意义：从已有表中拷贝数据，可以迅速让表中数据膨胀以测试表的压力和效率

3、更新数据

基本语法：update 表名 set 字段 = 值[where 条件];
高级操作：update 表名 set 字段 = 值[where条件][limit 更新数量];



4、删除数据
与更新类似，可以通过limit 来限制数量

在删除操作中，如果表中存在主键自增长，那么删除数据后，自增长的当前值不会发生改变（数据的删除是不会改变表结构的，此时要先删除表后再建表）
truncate 表名; -- 	清空表，然后重建这个表（表结构全部重置）


5、查询
基本语法：select 字段列表/* from 表名[where 条件];
完整语法：
select [select选项] 字段列表[字段别名]/*from 数据源 [where条件][group by 子句][having 子句][order by 子句][limit 子句];

select选项：对查出来的结果处理方式：
         (1)all : 默认的显示所有结果
         (2)distinct： 去重，完全重复的数据会把重复的过滤

字段别名：多表查询会有重名，需要重新命名
语法：字段名 [as] 别名


（以下为1月21号笔记，结合文档 0121.sql）

字段别名的使用请查看SQL文档


数据源：数据的来源
分类：单表数据源，多表数据源，查询语句

（1）单表数据源：select * from 表名;
（2）多        ：select * from 表名1,表名2....;从一张表中取出一条记录去另外一张表中匹配所有记录，而且全部保留，即笛卡尔积，没什么用，尽量避免
（3）子查询：来源是一条查询语句
select * from (select 语句) as 表名;



where 子句 用来筛选数据
返回结果：0或者1,0为false

判断条件：运算符：< > >= <= != <>(不等) = like between and in/not in  
         逻辑运算：&&（and）,||(or) , !(not)

原理：读取数据时就判断，失败就直接放弃，不占内存时间


条件查询，请查看SQL文档



group by 子句：根据某个字段分组
基本语法： group by 字段名;
分组的意义是为了统计数据，按组统计
SQL提供了一系列的统计函数
    group():统计分组后的记录数：每一组有多少记录
    max():统计每组中最大值
    min():统计最小值
    avg():统计平均值
    sum()：统计和
分组后没有进行过以上几条的统计那分组将毫无意义

count函数：参数两种
（1）* 号：代表统计记录
（2）字段名，代表统计对应的字段（不能为NULL，NULL不能运算）

分组自动按照分组字段默认升序
group by 字段 [asc\desc]; -- 对分组的结果合并后的整个结果进行排序


多字段分组：先根据一个字段分组，然后对分组后的结果再按照其他字段分组
group_concat()函数：连接字符串（保留该组的所有某个字段）



回溯统计：with rollup :会将分组字段置空
多字段回溯：考虑第一层分组会有回溯，第二次分组要看第一次分组的组数，组数是多少，回溯就是多少




having 子句：与where子句一样进行条件判断
where 是在磁盘判断，having 是在进入内存后进行分组判断操作
所以where 能做的基本上having都能做，而且having 能做where不能做的很多事
（1）分组统计的结果或者说统计函数只有having 能够使用
（2）having能够使用字段别名，where不能



order by ：排序，依赖校对集
语法： order by 字段名 [asc/desc];-- 默认asc升序



limit子句：限制数量，两种使用方式
（1）只用来限制长度
（2）限制起始位置和长度  ： limit 起始位置,长度

方式2主要实现数据的分页，为用户节省时间，提高服务器的效率，减少资源的浪费
于是，对用户来讲需要一个可以点击的分页按钮
对于服务器来讲根据用户选择的页码来获取不同的数据：limit offset,length;

lenth:每页显示的数据量，基本不变
offset: offset = (页码 - 1)*每页显示量


