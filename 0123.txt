（结合sql文档）

外键：foreign key   一张表可以有多个外键,但是外键名不能相同

增加外键：可以在创表时或者之后创建
（1）语法：foreign key(外键字段) references 外部表（主键字段）
外键要求字段必须先是一个索引，如不是则先回创建一个索引然后才会创建外键本身
（2）创表之后加外键：
alter table 表名 add[constraint 外键名字] foreign key(外键字段) references 父表（主键字段）;

查看外键 ： desc 表名

删除和新增：外键不可修改，只先删后新加
alter table 表名 drop foreign key 外键名;

外键作用：约束作用，对子表和父表都有


外键条件：
（1）保证表的存储引擎是innodb，否则外键可以创建成功但是不会有约束效果
（2）外键字段的字段类型必须与父表的类型完全一致
（3）一张表中外键名字不能重复，而且外键有关的错误信息提示不会太明确
（4）增加外键的字段（数据存在时），必须保证数据与父表主键对应



外键约束：可以不使用默认作用，有三种模式
    district:严格模式，默认的，父表不能删除或者更新一个已经被子表数据引用的数据
    cascade：级联模式，父表的操作对应表关联的数据也跟着操作
    set null：置空模式，父表的操作之后，子表对应的外键字段被置空

通常合理约束模式：删除时子表置空模式，更新时级联模式

指定模式的语法：
foreign key(外键字段) references 父表(主键字段) on delete 模式 on update 模式;


删除置空的前提： 外键字段允许为空，如果不满足条件外键无法创建

外键虽然强大，但是外键的约束会降低对数据的可控性，所以子实际开发中很少使用外键来处理，但是外键时非常重要的（关系型数据库需要外键来进行表与表之间的约束，连接）




联合查询：多次查询（多条select语句），记录上进行拼接，字段不会增加
语法：（每一条select语句获取的字段数必须严格一致，但与字段类型无关）
select 语句1 union[union 选项] select 语句2 ......；

union 选项：与select一样有两个
      all : 保留所有（select 选项是默认的这个）
      distinct：去重（union默认的）

意义：（1）查询同一张表但是需求不同（2）多表结构一样时查询

在联合查询中：order by 不能直接使用，要加括号，若要order by 生效，必须搭配limit，请看sql文档例子 






子查询 ：sub query
分类：
（1）按位置分类：
     from 子查询：子查询在from 后
     where子查询：子查询在条件中
     exists子查询：子查询在exists里面
    
（2）按结果分类
     标量子查询：子查询结果是一行一列
     列子查询：结果是一列多行
     行子查询：结果是多列一行，也可以多行多列？
          上面几个出现的位置在where之后
     表子查询：子查询结果多行多列，出现位置在from之后


标量子查询：
例：查询班级PHP0710的所有学生
（1）确定数据源 ： select * from my_student where c_id = ？；
（2）获取班级ID：select id from my_class where c_name = 'PHP0710'；
将语句（2）放入语句（1）的？处既可 


列子查询 通常需要in作为条件匹配，另外还有 all,some,any
其中 （=any）等价于 in
any 完全等价于 some
（=all）等价于 为全部


行子查询（查看sql文档）

表子查询：子查询返回的结果是当做二位表来使用（查看sql文档）

注意：是按照需求来决定是否用子查询的


exists子查询：用来判断某些条件是否满足，往往需要跨表，是接在where之后，返回的结果 0 和 1  







视图 view

创建视图
create view 视图名字 as select语句

查看视图：看结构
视图是一张虚拟表，也是表，表的所有查看方式都适用于视图


视图一旦创建，对应的文件夹下回创建一个对应的结构文件：frm文件


使用视图：主要是为了查询，将视图当做表，本质就是执行封装的select语句


修改视图
视图本身不可修改，但是其来源可以修改，所以修改视图即修改视图本身的来源语句（select语句）
alter view 视图名字 as 新的select语句


删除视图
drop view 视图名字;



视图意义：
（1）节省SQL语句：复杂语句可以用视图保存，以后可以直接对视图进行操作
（2）对数据相对安全，对视图的操作不会影响基表数据，
（3）视图往往在大项目中使用，而且是多系统使用，可以只对外提供有需要的信息也可以隐藏隐私性的数据（数据安全）
（4）视图可以对外提供友好性，不同的视图提供不同的数据，对外好像是专门设计的
（5）视图可以更好（容易）的进行权限控制



视图数据操作：视图可以进行数据操作但有限制

（1）新增数据：多表视图不能新增数据
（2）可以向单表视图中插入数据，但视图中包含的字段必须有基表中所有不能为空和没有默认值的字段
（3）删除数据：多表视图不能删除数据，单表视图可以删除
（4）更新数据：理论上无论单表还是多表都可以更新，
更新限制 ：with check option ，新增时，限定了某个字段有限制，那么在对视图进行数据更新操作时，系统会进行验证，要保证更新之后，数据依然能被视图查询，否则不让更新（查看sql文档）


但是对数据的操作应该是在基表中，在实际的工程中，视图只能用来查询数据而不能做其他的操作，会有一个权限的控制






视图算法：系统对视图以及外部查询视图select语句的解析方式
三种：
（1） undefined：未定义（默认的），即没有定义算法
（2）temptable：临时表算法，先执行视图中的select后外部select
（3）merge:合并算法，先将视图内的和外部select合并，然后执行（此效率高，因为只查一次，所以这个是系统常常选择的）

算法指定语句： create algorithm =指定算法 view 视图名字 as select语句;

视图算法选择：视图的select语句中包含一个查询子句，而且很有可能顺序比外部的查询语句靠后，则采用temptable，其他情况默认就OK










数据备份和还原
方式：数据表备份，单表数据备份，SQL备份，增量备份

数据表备份：不通过SQL，直接今年入文件复制相应的数据文件和表结构，还原时直接将复制的内容放入即可（不推荐）

数据表备份前提条件：根据不同的存储引擎

存储引擎：innodb和myisam(两种免费的)
innodb:只有表结构，数据全部存储在ibdata1文件中
myisam:表，数据和索引全部单独分开存储(直接复制三个文件即可备份，放在数据库下即可以使用)


单表数据备份：
每次只能备份一张表而且只能备份数据不能备份表结构
通常就是讲数据导出到文件

备份：select */字段列表 into outfile 文件所在路径（2018/01/23 22:30,未完待续）





